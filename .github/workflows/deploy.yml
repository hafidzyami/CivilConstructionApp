name: Deploy to VM

on:
  push:
    branches:
      - main
    # Opsional: Trigger jika ada perubahan di file tertentu saja agar hemat resource
    paths:
      - 'backend/**'
      - 'frontend/**'
      - '.github/workflows/**'
  workflow_dispatch:

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ------------------------------------------------------------------
  # JOB 1: BUILD & PUSH (Selective / Cerdas)
  # ------------------------------------------------------------------
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    # Kita butuh output variables untuk memberitahu job deploy (opsional, tapi bagus untuk log)
    outputs:
      backend: ${{ steps.changes.outputs.backend }}
      frontend: ${{ steps.changes.outputs.frontend }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # --- LOGIKA DETEKSI PERUBAHAN ---
      - name: Check for changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            backend:
              - 'backend/**'
            frontend:
              - 'frontend/**'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # --- BACKEND BUILD (Hanya jika folder backend berubah) ---
      - name: Extract metadata for Backend
        if: steps.changes.outputs.backend == 'true'
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}/backend
          tags: type=raw,value=latest

      - name: Build and push Backend image
        if: steps.changes.outputs.backend == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # --- FRONTEND BUILD (Hanya jika folder frontend berubah) ---
      - name: Extract metadata for Frontend
        if: steps.changes.outputs.frontend == 'true'
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}/frontend
          tags: type=raw,value=latest

      - name: Build and push Frontend image
        if: steps.changes.outputs.frontend == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          build-args: |
            NEXT_PUBLIC_API_URL=http://${{ secrets.VM_HOST }}:6969/api
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ------------------------------------------------------------------
  # JOB 2: DEPLOY
  # ------------------------------------------------------------------
  deploy:
    runs-on: ubuntu-latest
    needs: build-and-push
    
    steps:
      - name: Deploy to VM via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
          POSTGRES_PORT: ${{ secrets.POSTGRES_PORT }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          DOCKER_REGISTRY: ${{ env.DOCKER_REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          VM_HOST: ${{ secrets.VM_HOST }}
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          port: ${{ secrets.VM_PORT || 22 }}
          envs: POSTGRES_USER,POSTGRES_PASSWORD,POSTGRES_DB,POSTGRES_PORT,GITHUB_TOKEN,GITHUB_ACTOR,DOCKER_REGISTRY,IMAGE_NAME,VM_HOST
          script: |
            APP_DIR="/opt/civilconstruction"
            mkdir -p $APP_DIR && cd $APP_DIR

            # Login agar bisa pull image private
            echo "$GITHUB_TOKEN" | docker login $DOCKER_REGISTRY -u $GITHUB_ACTOR --password-stdin

            # Generate .env (Password aman terjaga)
            cat > .env <<EOF
            POSTGRES_USER=${POSTGRES_USER:-postgres}
            POSTGRES_PASSWORD=$POSTGRES_PASSWORD
            POSTGRES_DB=${POSTGRES_DB:-civilconstruction}
            POSTGRES_PORT=${POSTGRES_PORT:-5432}
            BACKEND_PORT=6969
            FRONTEND_PORT=6968
            NODE_ENV=production
            NEXT_PUBLIC_API_URL=http://$VM_HOST:6969/api
            DATABASE_URL=postgresql://${POSTGRES_USER:-postgres}:$POSTGRES_PASSWORD@host.docker.internal:${POSTGRES_PORT:-5432}/${POSTGRES_DB:-civilconstruction}?schema=public
            EOF
            chmod 600 .env

            # Generate docker-compose.yml
            cat > docker-compose.yml <<'COMPOSE_EOF'
            version: '3.8'
            services:
              backend:
                image: DOCKER_REGISTRY_PLACEHOLDER/IMAGE_NAME_PLACEHOLDER/backend:latest
                container_name: civilconstruction-backend
                restart: unless-stopped
                env_file: .env
                ports: ["${BACKEND_PORT:-6969}:6969"]
                extra_hosts: ["host.docker.internal:host-gateway"]
                environment:
                  NODE_ENV: production
                  PORT: 6969
                networks: [civilconstruction-network]
                command: sh -c "npx prisma migrate deploy && node dist/index.js"
                healthcheck:
                  test: ["CMD", "node", "-e", "require('http').get('http://localhost:6969/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"]
                  interval: 30s; timeout: 3s; retries: 3; start_period: 10s

              frontend:
                image: DOCKER_REGISTRY_PLACEHOLDER/IMAGE_NAME_PLACEHOLDER/frontend:latest
                container_name: civilconstruction-frontend
                restart: unless-stopped
                env_file: .env
                ports: ["${FRONTEND_PORT:-6968}:3000"]
                environment: { NODE_ENV: production }
                depends_on: { backend: { condition: service_healthy } }
                networks: [civilconstruction-network]
                healthcheck:
                  test: ["CMD", "node", "-e", "require('http').get('http://localhost:3000', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})"]
                  interval: 30s; timeout: 3s; retries: 3; start_period: 10s

            networks:
              civilconstruction-network:
                driver: bridge
            COMPOSE_EOF

            sed -i "s|DOCKER_REGISTRY_PLACEHOLDER|$DOCKER_REGISTRY|g" docker-compose.yml
            sed -i "s|IMAGE_NAME_PLACEHOLDER|$IMAGE_NAME|g" docker-compose.yml

            # --- KECERDASAN DOCKER COMPOSE ---
            # 1. Pull: Hanya akan mendownload layer baru jika ada image yang diupdate.
            #    Jika Frontend tidak di-build (tidak ada update), Docker akan bilang "Image is up to date".
            echo "‚¨áÔ∏è Pulling images..."
            docker compose pull

            # 2. Up: Hanya akan me-restart container yang imagenya berubah.
            #    Jika Frontend tidak berubah, container frontend TIDAK akan direstart. 
            #    Zero downtime untuk service yang tidak berubah!
            echo "üöÄ Updating containers..."
            docker compose up -d --remove-orphans
            
            echo "üßπ Pruning old images..."
            docker image prune -af

            # Verification Loop (sama seperti sebelumnya)
            echo "Waiting for services..."
            sleep 10
            # ... (Verifikasi Backend) ...
            for i in {1..6}; do
              if curl -s http://localhost:6969/health > /dev/null; then echo "‚úÖ Backend OK"; break; fi
              echo "‚è≥ Waiting Backend ($i/6)"; sleep 5
              if [ $i -eq 6 ]; then docker compose logs backend; exit 1; fi
            done
            # ... (Verifikasi Frontend) ...
            for i in {1..6}; do
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000)
              if [ "$STATUS" == "200" ]; then echo "‚úÖ Frontend OK"; break; fi
              echo "‚è≥ Waiting Frontend ($i/6)"; sleep 5
              if [ $i -eq 6 ]; then docker compose logs frontend; exit 1; fi
            done
            
            echo "üéâ Deployment Success!"